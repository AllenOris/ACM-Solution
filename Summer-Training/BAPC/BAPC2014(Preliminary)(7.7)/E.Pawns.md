# E.Pawns

标签（空格分隔）： 博弈论

----------
题目链接：https://nanti.jisuanke.com/t/28205

----------
题意：
----------


两个人轮流下棋，给定一个棋局，B在W上，白色的棋子W向上移动，黑色的棋子B向下移动，每次可移动一格。底行上的W棋子或顶行上的B棋子可以向前移动两个方格，前提是两个方格都是空的。W先手，无法移动的一方输。

----------
解析：
----------


首先想到胜负和W，B之间可走步数的奇偶性有关，然后顶行和底行且可以走两步的棋子有改变奇偶性的能力。

先考虑一种特殊情况，某一列中B在顶行且W在底行，这对两个棋子来说是一样的，这种出现次数记为cd。
1.n>5时，只要一方走两步改变了奇偶性，另一方可以学对方的走法，把奇偶性变回来，所以后续不用考虑这几列的步数。
2.n=3时不会出现这种情况，不考虑。
3.特殊情况n=4和n=5，因为他们一方走两步之后，另一方就没有走两步的能力了，是要考虑的，在后面讨论。

然后只有一方的棋子在顶行或者底行且该棋子可以走两步时：只要一方有改变奇偶性能力的棋子，另一方就会想要去优先破坏这种能力，比如：

B 
。 
。`W优先向上走三步，则B就没有破坏奇偶性的能力了，则cw+=3`
。
。
W

cw为W破坏B的能力棋子所需要走的步数
cb为B破坏W的能力棋子所需要走的步数

最后，对于那些没有棋子有机会走两步的列来说，双方都只能一步一步走，只要把可走步数累加即可。


----------


W的必胜情况：

1.n=4，且cd为奇数

这种情况下，cd为奇数，W作为先手无论如何都掌握最后一个改变奇偶的决定权，所以w只要在最后一个机会时判断当前局势决定是否改变奇偶性即可。

2.cw < cb

即B破坏W能力要走的步数多，那么W就有改变奇偶能力，W必胜。

3.cb = cw - 1或cb = cw且步数为奇
（这里的bushu指B在顶行且W在底行的情况不算的总步数）

cb = cw - 1时，因为W先走，下完（cb+cw）步之后，此时两人都刚好没有破坏奇偶性的能力，（cb+cw）为奇数，下一步轮到B下，剩余步数为（部分步数-cb-cw）为偶数，所以W必胜。
cb = cw时，同上，（cb+cw）为偶，下一步轮到W，剩余步数为奇，W必胜。

----------


最后考虑n=5的时候的特殊情况
比赛的时候这个情况我一直没想想清楚。。随便举个例子：

B 。。。B
。B 。。。
。。B 。。
。。。B 。
WWWWW

对于第一，五列那种双方都有能力的棋子来说，不管先手走一步还是两步，后手都可以走（3-i）步使这一列一人走一次然后作废，所以n=5时这种列也不考虑。
对于第二列，B要优先破坏W的能力。
对于第三，四列，只要数可走步数即可。

因为剩下的策略都满足上面的n>5时，所以n=5虽然有特殊，但是并不用考虑特殊策略。


----------

    #include <algorithm>
    #include <cstdio>
    #include <cstdlib>
    #include <cstring>
    #include <iostream>
    #include <map>
    #include <queue>
    #include <string>
    #include <set>
    
    using namespace std;
    const int N=40;
    char p[N][N];
    
    int main()
    {
        int t,num=0;
        scanf("%d", &t);
        while(t--){
            int n,m;
            int cw=0,cb=0,cd=0,bushu=0;
            scanf("%d%d",&n,&m);
            memset(p,0,sizeof(p));
            for(int i=1;i<=n;i++){
                for(int j=1;j<=m;j++){
                    cin>>p[i][j];
                }
            }
            for(int i=1;i<=m;i++){
                int b,w;
                for(int j=1;j<=n;j++){
                    if(p[j][i]=='B')b=j;
                    else if(p[j][i]=='W')w=j;
                }
                if(b==1&&w==n&&n>3)cd++;
                else{
                    if(b==1&&w>3)cw+=w-3;
                    else if(w==n&&b<n-2)cb+=n-2-b;
                    bushu+=(w-b-1);
                } 
            }
            if((n==4&&cd%2==1)||(cw<cb)||(((cb==cw-1)||(cb==cw))&&bushu%2==1))printf("White wins\n");
            else printf("Black wins\n");
        }
        return 0;
    }


